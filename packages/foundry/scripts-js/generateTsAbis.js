import {
  readdirSync,
  statSync,
  readFileSync,
  existsSync,
  mkdirSync,
  writeFileSync,
} from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { format } from "prettier";

const __dirname = dirname(fileURLToPath(import.meta.url));

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */`;

function getDirectories(path) {
  if (!existsSync(path)) {
    return [];
  }

  return readdirSync(path).filter(function (file) {
    return statSync(join(path, file)).isDirectory();
  });
}

function getFiles(path) {
  return readdirSync(path).filter(function (file) {
    return statSync(join(path, file)).isFile();
  });
}

function parseTransactionAndReceiptRun(filePath) {
  try {
    const content = readFileSync(filePath, "utf8");
    const broadcastData = JSON.parse(content);
    return {
      transactions: broadcastData.transactions || [],
      receipts: broadcastData.receipts || [],
    };
  } catch (error) {
    console.warn(`Warning: Could not parse ${filePath}:`, error.message);
    return [];
  }
}

function getDeploymentHistory(broadcastPath) {
  const files = getFiles(broadcastPath);
  const deploymentHistory = new Map();

  // Sort files to process them in chronological order
  let runFiles = files
    .filter(
      (file) =>
        file.startsWith("run-") &&
        file.endsWith(".json") &&
        !file.includes("run-latest")
    )
    .sort((a, b) => {
      // Extract run numbers and compare them
      const runA = parseInt(a.match(/run-(\d+)/)?.[1] || "0");
      const runB = parseInt(b.match(/run-(\d+)/)?.[1] || "0");
      return runA - runB;
    });

  // Fallback to run-latest.json if no other run files exist
  if (runFiles.length === 0 && files.includes("run-latest.json")) {
    runFiles = ["run-latest.json"];
  }

  for (const file of runFiles) {
    const { transactions, receipts } = parseTransactionAndReceiptRun(
      join(broadcastPath, file)
    );

    for (const tx of transactions) {
      if (tx.transactionType === "CREATE" || tx.transactionType === "CREATE2") {
        // Store or update contract deployment info
        deploymentHistory.set(tx.contractAddress, {
          contractName: tx.contractName,
          address: tx.contractAddress,
          deploymentFile: file,
          transaction: tx,
          receipt: receipts.find((r) => r.transactionHash === tx.hash),
        });
      }
    }
  }

  return Array.from(deploymentHistory.values());
}

function getArtifactOfContract(contractName) {
  // First try the standard path: out/{contractName}.sol/{contractName}.json
  const standardPath = join(__dirname, "..", `out/${contractName}.sol/${contractName}.json`);
  if (existsSync(standardPath)) {
    return JSON.parse(readFileSync(standardPath));
  }

  // If not found, search all .sol folders for the contract
  // This handles cases where contract name differs from file name (e.g., Diamond.sol contains RaffeRaceDiamond)
  const outDir = join(__dirname, "..", "out");
  if (!existsSync(outDir)) return null;

  const solFolders = readdirSync(outDir).filter(f => f.endsWith('.sol'));
  for (const folder of solFolders) {
    const artifactPath = join(outDir, folder, `${contractName}.json`);
    if (existsSync(artifactPath)) {
      return JSON.parse(readFileSync(artifactPath));
    }
  }

  return null;
}

function getInheritedFromContracts(artifact) {
  let inheritedFromContracts = [];
  if (artifact?.ast) {
    for (const astNode of artifact.ast.nodes) {
      if (astNode.nodeType == "ContractDefinition") {
        if (astNode.baseContracts.length > 0) {
          inheritedFromContracts = astNode.baseContracts.map(
            ({ baseName }) => baseName.name
          );
        }
      }
    }
  }
  return inheritedFromContracts;
}

function getInheritedFunctions(mainArtifact) {
  const inheritedFromContracts = getInheritedFromContracts(mainArtifact);
  const inheritedFunctions = {};
  for (const inheritanceContractName of inheritedFromContracts) {
    const artifact = getArtifactOfContract(inheritanceContractName);
    if (artifact) {
      const {
        abi,
        ast: { absolutePath },
      } = artifact;
      for (const abiEntry of abi) {
        if (abiEntry.type == "function") {
          inheritedFunctions[abiEntry.name] = absolutePath;
        }
      }
    }
  }
  return inheritedFunctions;
}

function processAllDeployments(broadcastPath) {
  const scriptFolders = getDirectories(broadcastPath);
  const allDeployments = new Map();

  scriptFolders.forEach((scriptFolder) => {
    const scriptPath = join(broadcastPath, scriptFolder);
    const chainFolders = getDirectories(scriptPath);

    chainFolders.forEach((chainId) => {
      const chainPath = join(scriptPath, chainId);
      const deploymentHistory = getDeploymentHistory(chainPath);

      deploymentHistory.forEach((deployment) => {
        const timestamp = parseInt(
          deployment.deploymentFile.match(/run-(\d+)/)?.[1] || "0"
        );
        const key = `${chainId}-${deployment.contractName}`;

        // Only update if this deployment is newer
        if (
          !allDeployments.has(key) ||
          timestamp > allDeployments.get(key).timestamp
        ) {
          allDeployments.set(key, {
            ...deployment,
            timestamp,
            chainId,
            deploymentScript: scriptFolder,
            deployedOnBlock: deployment?.receipt?.blockNumber,
          });
        }
      });
    });
  });

  const allContracts = {};

  allDeployments.forEach((deployment) => {
    const { chainId, contractName } = deployment;
    const artifact = getArtifactOfContract(contractName);

    if (artifact) {
      if (!allContracts[chainId]) {
        allContracts[chainId] = {};
      }

      allContracts[chainId][contractName] = {
        address: deployment.address,
        abi: artifact.abi,
        inheritedFunctions: getInheritedFunctions(artifact),
        deploymentFile: deployment.deploymentFile,
        deploymentScript: deployment.deploymentScript,
        deployedOnBlock:
          deployment?.deployedOnBlock &&
          Number(BigInt(deployment.deployedOnBlock)),
      };
    }
  });

  return allContracts;
}

function main() {
  const current_path_to_broadcast = join(__dirname, "..", "broadcast");
  const current_path_to_deployments = join(__dirname, "..", "deployments");

  const Deploymentchains = getFiles(current_path_to_deployments);
  const deployments = {};

  // Load existing deployments from deployments directory
  // Normalize addresses to lowercase for case-insensitive matching
  Deploymentchains.forEach((chain) => {
    if (!chain.endsWith(".json")) return;
    chain = chain.slice(0, -5);
    var deploymentObject = JSON.parse(
      readFileSync(`${current_path_to_deployments}/${chain}.json`)
    );
    // Normalize addresses to lowercase
    const normalizedDeployments = {};
    Object.entries(deploymentObject).forEach(([key, value]) => {
      normalizedDeployments[key.toLowerCase()] = value;
    });
    deployments[chain] = normalizedDeployments;
  });

  // Process all deployments from all script folders
  const allGeneratedContracts = processAllDeployments(
    current_path_to_broadcast
  );

  // Update contract keys based on deployments if they exist
  Object.entries(allGeneratedContracts).forEach(([chainId, contracts]) => {
    Object.entries(contracts).forEach(([contractName, contractData]) => {
      // Use lowercase address for lookup (addresses are normalized above)
      const deployedName = deployments[chainId]?.[contractData.address.toLowerCase()];
      if (deployedName) {
        // If we have a deployment name, use it instead of the contract name
        // Also try to use the ABI from the deployment name if it exists
        // (useful for Diamond pattern where proxy is deployed but interface ABI is preferred)
        const deployedNameArtifact = getArtifactOfContract(deployedName);
        if (deployedNameArtifact) {
          contractData.abi = deployedNameArtifact.abi;
          contractData.inheritedFunctions = getInheritedFunctions(deployedNameArtifact);
        }
        // Only rename if the names are different
        if (deployedName !== contractName) {
          allGeneratedContracts[chainId][deployedName] = contractData;
          delete allGeneratedContracts[chainId][contractName];
        }
      }
    });
  });

  const NEXTJS_TARGET_DIR = "../nextjs/contracts/";

  // Ensure target directories exist
  if (!existsSync(NEXTJS_TARGET_DIR)) {
    mkdirSync(NEXTJS_TARGET_DIR, { recursive: true });
  }

  // Generate the deployedContracts content
  const fileContent = Object.entries(allGeneratedContracts).reduce(
    (content, [chainId, chainConfig]) => {
      const cleanedChainConfig = Object.fromEntries(
        Object.entries(chainConfig).map(([contractName, contractData]) => {
          const { deploymentFile, deploymentScript, ...rest } = contractData;
          return [contractName, rest];
        })
      );
      return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(
        cleanedChainConfig,
        null,
        2
      )},`;
    },
    ""
  );

  // Write the files
  const fileTemplate = (importPath) => `
    ${generatedContractComment}
    import { GenericContractsDeclaration } from "${importPath}";

    const deployedContracts = {${fileContent}} as const;

    export default deployedContracts satisfies GenericContractsDeclaration;
  `;

  writeFileSync(
    `${NEXTJS_TARGET_DIR}deployedContracts.ts`,
    format(fileTemplate("~~/utils/scaffold-eth/contract"), {
      parser: "typescript",
    })
  );

  console.log(
    `üìù Updated TypeScript contract definition file on ${NEXTJS_TARGET_DIR}deployedContracts.ts`
  );
}

try {
  main();
} catch (error) {
  console.error("Error:", error);
  process.exitCode = 1;
}
